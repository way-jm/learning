### 前端架构
* 前后分离的缺点：前端缺乏独立部署的能力，整体流程依赖于后端
* NodeJs的广泛使用促进了前端技术的飞速发展
  * 各种打包工具
  * 多元化的前端开发方式
* 单页面架构
  * 优势:
    * 切换页面不需要刷新浏览器
    * 组件化提升开发效率
  * 缺点：
      * 不利于SEO，首屏时间长
* 总结：
   * 过于灵活的实现导致前端应用拆分过多，**维护困难**
   * 往往一个功能或需求会跨项目开发

* 微前端架构
 ###### 优势
  * 技术栈无关
  * 主框架不限制接入应用的技术栈，微应用具备完全自主权
  * 增量升级
  * 微前端是一种非常好的实施渐进式重构的手段和策略
  * 微应用仓库独立，前后端可以独立开发
  * 独立运行时
  * 每个微应用之间状态隔离，运行时状态不共享
  ###### 劣势
  * 接入难度大
  * 应用场景：移动端少-管理端多

### 软件设计原则
  * 单一职责原则
  * 开放封闭原则，扩展开放，修改封闭
  * 里氏替换原则 父类一定能够被子类替换
  * 最少知识原则
  * 接口隔离原则
  * 依赖倒置原则：高层次的模块不应该依赖于低层次的模块，他们都应该依赖于抽象，抽象不应该依赖于具体实现，具体实现应该依赖于抽象

### 架构分层
   * 系统级
   * 应用级
   * 模块级
   * 代码级

### 微前端
  * 单实例：即同一时刻，只有一个子应用被展示，子应用具备一个完整的应用生命周期。
  * 多实例：通常基于url的变化来做子应用的切换。同一时刻可以展示多个子应用。通常使用web components做防撞
    子应用更像一个组件，而非一个应用
  * 实现方式对比
    *.iframe postMessage
      * 技术成熟
      * 支持页面嵌入
      * 天然支持运行沙箱隔离，独立运行
      * 页面之间可以是不同域名--加重复杂程度
      * 需要对应的设计一套通讯机制，如何监听，传参格式等内容
      * 应用的加载，渲染，缓存控制手段比较少，交给浏览器
   *. web component
      * 支持自定义元素
      * 支持shadow dow,通过关联进行控制
      * 支持模板template和插槽，引入自定义组件内容
      * 接入微前端需要重写当前项目
      * 生态系统不完善，技术过新，容易出现兼容性问题
      * 整体架构复杂，组件与组件之间拆分过细，容易出现通信控制繁琐
   *. 自研框架
      * 高度定制化，满足需要兼容的一切场景
      * 独立的通信机制和沙箱运行环境，可以解决应用之间相互影响的问题
      * 支持不同的技术栈子应用，可以无缝实现页面无刷新渲染
      * 技术实现难度大
      * 需要设计一套定制的通信机制
      * 首次加载会资源过大的情况
  #### 目标-自研框架
      * 路由分发
      * 主应用控制路由匹配和子应用加载，共享依赖加载
      * 子应用做功能，并接入主应用实现主子控制和联动

  ### 主应用
    * 注册子应用
    * 加载、渲染子应用
    * 路由匹配（activewhen,rules --由框架判断）
    * 获取数据（公共依赖，通过数据做鉴权处理）
    * 通信（父子通信，子父的通信）
  ### 子应用  
    * 渲染
    * 监听通信
  ### 微前端框架
    * 子应用的注册
    * 又开始内容（应用加载完成）
    * 路由更新判断
    * 匹配对应的子应用
    * 加载子应用的内容
    * 完成所有依赖的执行
    * 将子应用渲染在固定容器内
    * 公共事件的管理
    * 异常的捕获和报错
    * 全局的状态管理的内容
    * 沙箱隔离
  
  ### 服务端
    提供数据服务

  ### 发布平台
    主子应用的打包发布

### 微前端项目架构
![项目架构](https://raw.githubusercontent.com/way-jm/learning/master/packages/microFE/micro-constrct.png)

## 开发
### 用一个run.js 启动多个子应用

    
    
